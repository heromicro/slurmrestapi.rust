/*
 * Slurm Rest API
 *
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.39
 * Contact: sales@schedmd.com
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct V0Period0Period39UpdateNodeMsg {
    #[serde(rename = "comment", skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    #[serde(rename = "cpu_bind", skip_serializing_if = "Option::is_none")]
    pub cpu_bind: Option<i32>,
    #[serde(rename = "extra", skip_serializing_if = "Option::is_none")]
    pub extra: Option<String>,
    #[serde(rename = "features", skip_serializing_if = "Option::is_none")]
    pub features: Option<Vec<String>>,
    #[serde(rename = "features_act", skip_serializing_if = "Option::is_none")]
    pub features_act: Option<Vec<String>>,
    #[serde(rename = "gres", skip_serializing_if = "Option::is_none")]
    pub gres: Option<String>,
    #[serde(rename = "address", skip_serializing_if = "Option::is_none")]
    pub address: Option<Vec<String>>,
    #[serde(rename = "hostname", skip_serializing_if = "Option::is_none")]
    pub hostname: Option<Vec<String>>,
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<Vec<String>>,
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<Vec<State>>,
    #[serde(rename = "reason", skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    #[serde(rename = "reason_uid", skip_serializing_if = "Option::is_none")]
    pub reason_uid: Option<String>,
    #[serde(rename = "resume_after", skip_serializing_if = "Option::is_none")]
    pub resume_after: Option<Box<crate::models::V0Period0Period39Uint32NoVal>>,
    #[serde(rename = "weight", skip_serializing_if = "Option::is_none")]
    pub weight: Option<Box<crate::models::V0Period0Period39Uint32NoVal>>,
}

impl V0Period0Period39UpdateNodeMsg {
    pub fn new() -> V0Period0Period39UpdateNodeMsg {
        V0Period0Period39UpdateNodeMsg {
            comment: None,
            cpu_bind: None,
            extra: None,
            features: None,
            features_act: None,
            gres: None,
            address: None,
            hostname: None,
            name: None,
            state: None,
            reason: None,
            reason_uid: None,
            resume_after: None,
            weight: None,
        }
    }
}

/// 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum State {
    #[serde(rename = "INVALID")]
    Invalid,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "DOWN")]
    Down,
    #[serde(rename = "IDLE")]
    Idle,
    #[serde(rename = "ALLOCATED")]
    Allocated,
    #[serde(rename = "ERROR")]
    Error,
    #[serde(rename = "MIXED")]
    Mixed,
    #[serde(rename = "FUTURE")]
    Future,
    #[serde(rename = "PERFCTRS")]
    Perfctrs,
    #[serde(rename = "RESERVED")]
    Reserved,
    #[serde(rename = "UNDRAIN")]
    Undrain,
    #[serde(rename = "CLOUD")]
    Cloud,
    #[serde(rename = "RESUME")]
    Resume,
    #[serde(rename = "DRAIN")]
    Drain,
    #[serde(rename = "COMPLETING")]
    Completing,
    #[serde(rename = "NOT_RESPONDING")]
    NotResponding,
    #[serde(rename = "POWERED_DOWN")]
    PoweredDown,
    #[serde(rename = "FAIL")]
    Fail,
    #[serde(rename = "POWERING_UP")]
    PoweringUp,
    #[serde(rename = "MAINTENANCE")]
    Maintenance,
    #[serde(rename = "REBOOT_REQUESTED")]
    RebootRequested,
    #[serde(rename = "REBOOT_CANCELED")]
    RebootCanceled,
    #[serde(rename = "POWERING_DOWN")]
    PoweringDown,
    #[serde(rename = "DYNAMIC_FUTURE")]
    DynamicFuture,
    #[serde(rename = "REBOOT_ISSUED")]
    RebootIssued,
    #[serde(rename = "PLANNED")]
    Planned,
    #[serde(rename = "INVALID_REG")]
    InvalidReg,
    #[serde(rename = "POWER_DOWN")]
    PowerDown,
    #[serde(rename = "POWER_UP")]
    PowerUp,
    #[serde(rename = "POWER_DRAIN")]
    PowerDrain,
    #[serde(rename = "DYNAMIC_NORM")]
    DynamicNorm,
}

impl Default for State {
    fn default() -> State {
        Self::Invalid
    }
}

